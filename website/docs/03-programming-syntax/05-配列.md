---
title: "配列"
sidebar_position: 5
---

# データを一つの変数にまとめる

## 単一次元の配列（1次元配列）

配列とは、データをまとめて管理する方法の1つです。
変数1つに同じ型の複数の値を入れられるようにします。

### 配列を使用するには

+ 配列の宣言
+ 領域の確保
+ 配列の各要素へのアクセス
+ まとめて初期化
+ 配列の領域数を取得

#### 配列の宣言

配列を宣言するには、型名か変数名の後に`[]`を付けます。

```java
int[] a;
int a[];
```

どちらでも同じです。

#### 領域の確保

配列を宣言しただけでは使えません。
配列に、どれだけの要素を入れるかを指定する必要があります。

```java
int[] scores;		      // 宣言
scores = new int[5];	// 領域を5つ確保する
```

`scores[0]〜scores[4]`までの領域が確保されます。

また、Javaでは配列のインデックスは0から始まります。5つの要素数を持つ配列の場合は、インデックスは順番に0,1,2,3,4となります。


`new`演算子は、インスタンス化を明示的に行う制御構文です。配列の初期化の他に、参照型変数へのインスタンス化と代入の際に使用するほか、単純にインスタンス化してメソッドを呼び出したいときなどに使用する大変重要な演算子です。


#### 配列の各要素へのアクセス
配列の各要素へは、`[]`中に配列のインデックス（整数値）を指定することでアクセス可能です。

```java
//各要素へ代入
scores[0] = 74;
scores[1] = 88;
scores[2] = 98;
scores[3] = 53;
scores[4] = 25;

// 指定したインデックスの要素を取り出し
System.out.println(scores[3]); // 上から4つめの要素を表示しているので、53と表示される
```

#### まとめて初期化

配列の宣言と領域の確保を同時に行う場合は以下のように書けます。

```java
int[] scores;		      // 宣言
scores = new int[5];	// 領域を5つ確保する
// ↓ 宣言と同時に領域確保
int[] scores = new int[5];
```

配列の宣言と、領域の確保、値の代入をまとめて行う場合は、`{ }`を使い、リテラルをカンマ区切りで必要数分記入します。

```java
int[] scores = {74, 88, 98, 53, 25};
```

#### 配列の領域数を取得
確保された領域の数を取得するには、配列の変数の`length`を参照します。

```java
int[] scores = {74, 88, 98, 53, 25};
System.out.println(scores.length);    // 5と表示
```

for文の条件や、配列の要素の最後にアクセスする場合などに使用できます。

```java
int[] scores = {74, 88, 98, 53, 25};

// 要素の最後にアクセス
System.out.println(scores[scores.length - 1]); //25と表示される

// 各要素を順に表示
for (int i = 0; i < scores.length; i++) {
  System.out.print(scores[i] + ", "); // 74, 88, 98, 53, 25と表示される。
}
```

## 複数次元の配列(多次元配列)
先ほどまでのは、1次元配列と呼ばれるものです。要素は単一のインデックス（整数値による連番:0からスタート）でアクセスできます。
それに対して、複数の次元を持たせた配列を使うこともできます。

```java
// 教科ごとの点数(1次元)を生徒ごと(2次元)で管理したい
int[][] scoresOfStudents = new int[3][5];
```

必要な次元の数だけ`[]`をつなげます。

#### 配列の各要素へのアクセス

基本は1次元配列と同じです。

```java
// 一人目の点数を代入
scoresOfStudents[0][0] = 100;
scoresOfStudents[0][1] = 70;
scoresOfStudents[0][2] = 50;
scoresOfStudents[0][3] = 98;
scoresOfStudents[0][4] = 45;
// 二人目
scoresOfStudents[1][0] = 70;
scoresOfStudents[1][1] = 70;
scoresOfStudents[1][2] = 45;
scoresOfStudents[1][3] = 68;
scoresOfStudents[1][4] = 70;

// ...以下省略
```

#### まとめて初期化

{}をカンマで区切ることで、多次元の配列を同時に宣言、初期化、代入ができます。

```java
int[][] scoresOfStudents = {
    {70, 60, 80, 90, 50},
    {81, 45, 32, 78, 100},
    {32, 44, 34, 55, 70},
};
```

#### 配列の領域数を取得
先ほどの多次元配列にて

```java
System.out.println(scores.length);    //3と表示
```

次元ごとの領域数を取得するには、

```java
System.out.println(scores[0].length);    //5と表示
```


# 配列内のデータを降順でソートするサンプル

以下のソースコードは、隣り合った値同士を比較し、数値を降順で並び替えるプログラムです。

ファイル名: `ArraySortSample.java`


```java
import java.util.Scanner;
public class ArraySortSample {
  public static void main(String[] args) {
    Scanner in = new Scanner(System.in);

    int[] test = new int[5];
    System.out.println(test.length + "人の点数を入力してください。");

    for (int i = 0; i < test.length; i++) {
      String str = in.nextLine();
      test[i] = Integer.parseInt(str);
    }

    for (int s = 0; s < test.length - 1; s++) { // 0〜3までのループ(比較元 s;source)
      for (int t = s + 1; t < test.length; t++) { // (s + 1)〜4までのループ(比較先 t;target)
        if (test[s] < test[t]) {
          //降順で並び替えるため、比較元より比較先が大きければ以下の入れ替え処理を行う
          int tmp = test[t];  // 比較先(t)の示す要素を一時保存(tmp)
          test[t] = test[s];  // 比較先(t)の示す要素へ、比較元(s)の示す要素を上書き
          test[s] = tmp;      // 比較元(s)の示す要素へ、tmpへ一時保存されていた比較先(t)を上書きして、比較元と比較先を入れ替えた
        }
      }
    }

    for (int i = 0; i < test.length; i++) {
      System.out.println((i + 1) + "番目の人の点数は" + test[i] + "です。");
    }
  }
}
```

ソートの