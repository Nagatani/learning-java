---
title: "条件分岐"
sidebar_position: 3
---

プログラミングのもっとも重要でもっともバグを出しやすい部分です。

## if文による条件分岐

### if – 基本的な書き方

括弧内の条件（*boolean型*）に合致する（値が`true`）の場合に、波括弧`{ }`内のブロックの処理を行います。

```java
if ( 条件 ) {
    ここは条件に合致した場合にのみ実行される
}
```

波括弧のブロックは、実行する処理が1行の場合のみ省略が可能ですが、波括弧は省略しない方が良いです。

もし、条件に合致した場合実行する処理が1行だけのとき、次の書き方のように改行を挟まず1行で書くようにすると分かりやすいです。

```java
if ( 条件 ) ここは条件に合致した場合にのみ実行される
```

波括弧を省略してほしくない理由は、次のようなパターンが考えられるからです。

```java
if ( 条件 )
    最初にif文を書いた人が書いた条件内のコード
```

これは正常に動きます。  
次に、このコードを改修する際、以下のようなコードの修正を行ってしまいやすい点が波括弧を省略した際に起こりやすいです。

```java
if ( 条件 )
    最初にif文を書いた人が書いた条件内のコード
    追加された条件内コードのつもりで書かれたコード
```

このとき、追加されたコードは、ifの条件にまったく関係なく処理が実行されてしまい、これが意図しない処理としてバグにつながります。
すぐに気付けるようだったら良いのですが、追加されたコードの影響が、かなり後の方（たとえばリリース後など）で気付く状況も少なからずあります。
そもそも波括弧を省略していなければ防げているバグを発生させないためにも、必ず波括弧を書きましょう。

少し逸れますがバグの混入を防ぐ話として、インデントを揃えることも重要です。  
インデントはタブでもスペースでも構いませんが、コードブロックが分かりやすくなるように適切な字下げをしましょう。  
また、インデントに関していえば、IDEに搭載されているコードフォーマッタを使うのもよいです。自動的にコードの整形を行ってくれるため、先ほどの追加コードのような不具合もコードの整形によって気付きやすくなります。

#### if文の条件に使う比較演算子(関係演算子)

プリミティブ型に対して、等しい異なる大きい小さいなどの評価を行う演算子を比較演算子と呼びます。
（原則プリミティブ型に対してのみ使うことができるものなので忘れないこと）

比較演算子の結果は、boolean型となります。
結果がtrueである場合に、「条件に合致している」といえます。そのため、比較演算子を用いた両辺の比較だけでなく、関数呼び出しの戻り値を条件とするような使い方も可能です。

等しいことを評価する `==`（関係演算子）は、 `=`（代入演算子）と間違えやすいので気を付けましょう。


##### 比較演算子一覧
※両辺を比較する場合に使用し、演算子の結果はboolean型で戻ってきます。

| 演算子 | 例 | 説明
|----------|------|------|
| `==` | `a == b` | aとbが等しいときtrue
| `!=` | `a != b` | aとbが等しくないときtrue
| `>` | `a > b` | aがbより大きいときtrue
| `<` | `a < b` | aがbより小さいきとtrue
| `>=` | `a >= b` | aがb以上のときtrue
| `<=` | `a <= b` | aがb以下のときtrue

### if-else – どちらかを実行
ifの条件に合致しなかった場合のみ実行される処理を書ける

```java
if ( 条件 ) {
    ここは条件に合致した場合にのみ実行される
} else {
    条件に合致しなかった場合にのみ実行される
}
```

### if-elseif-else – 複数の条件
条件に合致しなかった場合、再度評価を行うこともできる

```java
if ( 条件1 ) {
    条件1に合致した場合にのみ実行される
} else if ( 条件2 ) {
    条件1に合致せず、条件2に合致した場合
} else {
    上記すべての条件に合致しなかった場合
}
```

### 比較演算子と論理演算子を組み合わせた複数条件指定
if文の条件は、条件1かつ条件2と言ったように、1つのif文で複数の条件を入れることが可能です。

その時に使用する演算子が、論理演算子（ショートサーキット演算子）と呼ばれるものです。

#### 論理演算子(ショートサーキット演算子)

※両辺ともbooleanの場合に使用します。

| 演算子 | 例 | 説明
|----------|------|------|
| `&&` | `a && b` | aとbの両方がtrueのときtrue
| <code>&#x7C;&#x7C;</code> | <code>a &#x7C;&#x7C; b</code> | aとbのどちらかがtrueのときtrue
| `!` | `!a` | aがfalseのときtrue。逆になる


### AND（〜かつ〜）
```java
if ( 条件１ && 条件２ ) {
    条件１と条件２どちらにも合致した場合にのみ実行される
}
```

### OR（〜または〜）
```java
if ( 条件１ || 条件２ ) {
    条件１か条件２のどちらかに合致した場合にのみ実行される
}
```

## 式の中でif elseを実現する三項演算子
三項演算子は、`if...else...`を式として扱えます。

```java
System.out.println(条件 ? "true" : "false");
//条件に合致していればtrueと表示されます。合致していなければfalseと表示されます。

//↑の処理と同じように書く場合↓
if ( 条件 ) {
    System.out.println("true");
} else {
    System.out.println("false");
}
```

式の中で条件分岐を実現でき、結果を切り替えることができるため大変便利です。

## switch文による条件分岐
### 一つの値に対する条件分岐

1つの式（変数でも演算子を用いた式でもよい）に対して、それぞれの値と等しいかを条件分岐したい場合には、以下のようにも書けます。

```java
switch ( 式 ) {
    case 値1:
        式の結果が値1と等しい時に処理を実行
        break;
    case 値2:
        式の結果が値2と等しい時に処理を実行
        break;
    default:
        上記のどの値とも等しくない時に処理を実行
        break;
}
```

上記のコードは、以下のif…else if…elseと同義です。

```java
if ( 式 == 値1 ) {
    式の結果が値1と等しい時に処理を実行
} else if ( 式 == 値2 ) {
    式の結果が値2と等しい時に処理を実行
} else {
    上記のどの値とも等しくない時に処理を実行
}
```

#### switch文の注意点
条件分岐後の処理を書いたら、break;でswitch文を抜けるようにしないといけない。

以下の書き方を行った場合、`case 値1`で処理するべき以降の条件が意図したものと違ってしまいます。

```java
switch ( 式 ) {
    case 値1:
        式の結果が値1と等しい時に処理を実行
    case 値2:
        式の結果が値1と等しい時と値2と等しい時に処理を実行
        //↑本来は、「式の結果が値2と等しい時に処理を実行」のつもりで書いたが、
        // break;を忘れたことで意図しない条件が追加されてしまっている。
        break;
    default:
        上記のどの値とも等しくない時に処理を実行
        break;
}
```

この特性を利用して、以下のように応用することも可能です。

複数の値で式を評価する
```java
switch ( 式 ) {
    case 値1:
    case 値2:
        式の結果が値1か値2と等しい時に処理を実行
        break;
    default:
        上記のどの値とも等しくない時に処理を実行
        break;
}
```

----

## String型の内容評価について

次のサンプルプログラムをよく見て、実行してみましょう。

```java
public class StringEval {
  public static void main(String[] args) {

    String a = "Hello";
    String b = "Hello";

    if (a == b) {
      System.out.println("同じだよ！");  // こっち
    } else {
      System.out.println("違うよ！");
    }

    // a,b両方に処理を加えて値を変化させる
    a += 1;
    b += 1;
    System.out.println("a:" + a);
    System.out.println("b:" + b);

    if (a == b) {
      System.out.println("同じだよ！");
    } else {
      System.out.println("違うよ！");   // こっち
    }
  }
}
```

変数`a`, `b`どちらも、値としては`"Hello"`, `"Hello1"`となっており、見た目上同じ文字列ですが、2つ目の条件分岐が意図しない結果になったと思います。


Javaの言語仕様で注意してほしいのが、***String型は唯一特別扱いされるクラス型***であるということです。

String型の初期化時点や、String型のリテラルは、どれも擬似的にプリミティブ型と同じような動作をします。しかし、値の変化が発生する処理を一度行われると、その変数は通常のクラス型変数と同じ動作をするように切り替わります。

クラス型変数を変数に格納されている値を比べる演算子で比較したとしても、`true`になりません。
理由は、変数の格納されているデータはクラス型のインスタンスが格納されているメモリアドレスのみを保持しているからです。

もう少し詳しく書くと、次のようになります。

1. クラス型の変数宣言時、変数にはnullが初期値で代入されている
2. new構文を用いてインスタンス化が行われた際にメモリ上へオブジェクトが展開される
3. 展開されたオブジェクトが格納されているメモリアドレスを変数が保持する

ここで注意してほしいのが、メモリアドレスです。

上記のプログラムについて、変数`a`, `b`のメモリアドレスが格納されている値が違うということを確認する方法はJavaにはありませんが、擬似的にハッシュ値を用いた比較を行い、比較演算子で単純な比較はできないことが確認できます。  
次のプログラムを確認してみましょう。

```java
public class StringEval {
  public static void main(String[] args) {

    // この初期化方法によって得られるString型は疑似プリミティブ
    String a = "Hello";
    String b = "Hello";

    // System.identityHashCode()によってハッシュ値を取得
    System.out.println("a:" + System.identityHashCode(a));
    System.out.println("b:" + System.identityHashCode(b));
    // この時点ではハッシュ値は同じ

    if (a == b) {
      System.out.println("同じだよ！");  // こっち
    } else {
      System.out.println("違うよ！");
    }

    // a,b両方に処理を加えて値を変化させる
    a += 1;
    b += 1;
    System.out.println("a:" + System.identityHashCode(a));
    System.out.println("b:" + System.identityHashCode(b));
    // 文字の連結によって、a,bの参照しているオブジェクトがそれぞれ計算された別のものへと変化した

    if (a == b) {
      System.out.println("同じだよ！");
    } else {
      System.out.println("違うよ！");   // こっち
    }
  }
}
```

コード内のコメントにて説明を書きましたが、内部的な値（String型などのクラス型の場合メモリアドレス）をハッシュ値で見ることによって値が変化していることが分かります。

## Stringなどのクラス型の比較方法

`Object#equals`メソッドを使って比較しましょう。

Javaにおけるすべてのクラス型のもととなっているObject型には、値を比較するためのメソッド`equals()`が用意されています。このメソッドは、インスタンス化されたオブジェクトと、引数で渡したオブジェクトの値となるもの同士を比較し、同じであれば`true`を返します。  
`equals()`メソッドは、インスタンス化されたオブジェクトでしか使用できません。初期化されていない（つまり変数の値がnullである状態の）時に`equals()`メソッドを呼び出すと、NullPointerExceptionと呼ばれる例外が発生します。※そのメソッドを持っているオブジェクトはインスタンス化されてないから呼び出せないよ！っていうエラーです。

`equals()`メソッドを使うことで、String型の文字列が同じかどうかを比較することが可能です。

次のプログラムを確認してみましょう。

```java
public class StringEquals {
  public static void main(String[] args) {

    String a = "Hello";
    String b = "Hello";

    System.out.println("a:" + System.identityHashCode(a));
    System.out.println("b:" + System.identityHashCode(b));

    if (a.equals(b)) {
      System.out.println("同じだよ！");  // こっち
    } else {
      System.out.println("違うよ！");
    }

    a += 1;
    b += 1;
    System.out.println("a:" + System.identityHashCode(a));
    System.out.println("b:" + System.identityHashCode(b));

    if (a.equals(b)) {
      System.out.println("同じだよ！");  // こっち
    } else {
      System.out.println("違うよ！");
    }
  }
}
```

実行結果を確認すると、きちんと意図した結果になったと思います。

このように、内部的な動作を知っておかないと現象を理解できない場合もありますが、文字列を始めとした***クラス型の比較はequals()を使う***ということを必ず覚えておきましょう。

ちなみに、「同じでない」を表現するには、`!a.equals(b)`が利用できます。


## switch式の余談：Stringをswitch式で評価することもできる
JavaSDKのversion 7以降、switchの評価式にStringの文字列型を使用することができるようになりました。  
文字列をより簡単に評価できる反面、評価するString型の変数が初期化されていない場合は例外が発生してしまうなどの注意点があります。
文字列をswitchしたい場合で評価する式の結果が判断に困るのなら、switch式の事前にnullとの比較（`target == null`）を行うなどの事前処理を行うか、最初からif-elseif-elseの形式で書いた方が安全です。
