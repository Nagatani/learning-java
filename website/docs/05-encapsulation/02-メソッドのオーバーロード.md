---
title: メソッドのオーバーロード
sidebar_position: 2
---

## オーバーロード

オーバーロードとは、同じクラス内で同じ名前のメソッドを複数定義することができる機能です。  
ただし、それぞれのメソッドは異なる引数の型や数を持つ必要があります。オーバーロードを使用することで、同じ名前のメソッドで異なるパラメータを受け取り、その型や数に応じて異なる動作を実行できます。

Javaでは、同じメソッド名でも以下の条件の場合には複数定義できます。

- 戻り値の型が同じ
- 引数の型が異なる
- 引数の数が異なる

たとえば、

```java
public void setValues() { … }
public void setValues(int val) { … }            //引数の型が異なる
public void setValues(double val) { … }         //引数の型が異なる
public void setValues(int val1, int val2) { … } //引数の数が異なる
public void setValues(int[] values) { … }       //引数の型が異なる
```

これらはすべて同じクラス内で定義できます。

それに対して、

```java
public void setValues(int val) { … }
public void setValues(int val2) { … }           //引数の数も型も同じなので定義不可
public int setValues(double val) { … }          //引数の型は違うけど戻り値が異なるため定義不可
```

以上のメソッドは、1行目以外は定義できません。

このように、同じ名前のメソッドを複数定義することを、メソッドの **オーバーロード** と呼びます。

### クラスへのオーバーロード実装例

```java
public class Calculator {

  // 整数の足し算を行うメソッド
  public int add(int a, int b) {
    return a + b;
  }

  // 小数の足し算を行うメソッド
  public double add(double a, double b) {
    return a + b;
  }
}
```

上記の例では、`Calculator`クラスに`add`という名前のメソッドが2つ定義されています。  
1つ目のメソッドは2つの整数を受け取り、その和を返します。  
2つ目のメソッドは2つの小数を受け取り、その和を返します。  
これらのメソッドは、引数の型が異なるため、オーバーロードが適用されています。

オーバーロードのメリットは、同じ名前で異なる引数を受け取るメソッドを作成できるため、作成したクラスを使う際にシンプルでわかりやすくなります。  
また、関連する処理を1つのメソッド名にまとめることができ、コードの可読性や保守性が向上します。

オーバーロードを使用する際の注意点として、以下が挙げられます。

1. 引数の型や数が異なる必要がある。
1. 戻り値の型だけが異なる場合、オーバーロードは適用されません。
1. 引数の型が似ていて互換性がある場合（たとえば、intとlong）、呼び出し時にどのメソッドが呼ばれるかが曖昧になる可能性があります。

### オーバーロードが適用されない例

同じメソッド名でオーバーロードが適用されないケースは、主に引数の型や数が同じであるか、戻り値の型だけが異なる場合です。以下に、オーバーロードが適用されない例を示します。

#### 例1: 引数の型と数が同じ

```java
public class InvalidOverload {

  public void showMessage(String message) {
    System.out.println("メッセージ: " + message);
  }

  // このメソッドはオーバーロードできない（引数の型と数が同じ）
  public void showMessage(String input) {
    System.out.println("入力: " + input);
  }
}
```

この例では、`showMessage`メソッドが2つ定義されていますが、どちらもString型の引数を1つだけ受け取っています。そのため、これらのメソッドはオーバーロードできません。

#### 例2: 戻り値の型だけが異なる

```java
public class InvalidOverload {

  public int square(int a) {
    return a * a;
  }

  // このメソッドはオーバーロードできない（戻り値の型だけが異なる）
  public double square(int a) {
    return (double) a * a;
  }
}
```

この例では、`square`メソッドが2つ定義されていますが、どちらもint型の引数を1つだけ受け取っています。戻り値の型が異なっていても、引数の型と数が同じであるため、これらのメソッドはオーバーロードできません。

オーバーロードを適用するには、引数の型や数が異なる必要があります。それぞれのメソッドが異なる引数を受け取ることで、コンパイラはどのメソッドを呼び出すべきか判断できます。

### オーバーロードは多態性を実現する

**多態性** とは、オブジェクト指向プログラミングなどの型システムの性質を表す用語です。
機能や状態を表す要素の名前において、それ自体の型により異なる機能や状態を表現できることを指します。

多態性は、**ポリモーフィズム** (Polymorphism)とも呼ばれます。  
(対義語として、単態性:モノモーフィズムという型システムの言語もあります。)

#### 多態性の例

人間の行動（メソッド）に関して、たとえば「食べる」を考えてみましょう。

動作名に関しては単に食べるだけですが、何を食べますか？何が食べられて、何が食べられませんか？  
この、「何を」が引数にあたります。

戻り値は、行動によって起こる結果を返すイメージで良いでしょう。
何を食べたとしてもそれによって起こる結果の形式は変わりがないかと思います。

戻り値以外にも内部的な状態（フィールドや変数）の変化もあります。「食べる」ことを考えると、こちらの方が変化が大きいような気もしますが、今回はそれを考えないものとしています。

### まとめ
メソッド名は同じでも引数の型、数を変えることで、複数定義でき、型により機能を変えることができます。
これを **多態性** と呼び、オブジェクト指向プログラミングにおけるプログラミングの柔軟性を持たせられます。
