---
title: コンストラクタ
sidebar_position: 3
---

## インスタンス生成時に初期化処理を行う

その場合には、**コンストラクタ** と呼ばれるクラスのインスタンス化時初期化を行う特殊メソッドを定義します。
初期化処理をクラス側に任せることで、クラスの利用者が気にしなければならないことが減ります。
作成したクラスを間違った初期化処理で使用され、バグの発生要因となることをなくすためにも、クラス作成者（設計者）はコンストラクタで初期化処理を定義することを心がけましょう。


### コンストラクタとは
**戻り値のない**、**クラス名と同じ名前のメソッド** として定義され、クラスがインスタンス化された際に初期化する処理などを担うメソッドです。

### コンストラクタの書式
`MyClass`という名前のクラスにコンストラクタを定義するとします。

```java
public class MyClass {

    public MyClass() {
        //ここにMyClassのフィールドを初期化する処理などを書きます。
    }
}
```

`public MyClass() { ... }`とした部分が、コンストラクタです。


### コンストラクタはどこで呼ばれるか

クラスに定義されたコンストラクタは、new演算子によりインスタンス化されたタイミングで呼ばれます。

上記MyClassを使用する際に、

```java
MyClass mc = new MyClass();
```

として`new`でインスタンス化をしたときに呼び出されます。


### コンストラクタには引数も付けられる

コンストラクタには、引数を設定できます。

```java
public class MyClass {

    public MyClass() {
        //ここにMyClassのフィールドを初期化する処理などを書きます。
        //引数が渡されなかった場合はこちらが呼ばれます。
    }
    public MyClass(int val) {
        //MyClassがインスタンス化された際に、int型の引数が渡された場合はこちらが呼ばれます。
    }
    public MyClass(int val1, double val2) {
        //MyClassがインスタンス化された際に、int型とdouble型の引数が2つ渡された場合はこちらが呼ばれます。
    }
}
```

上記例のように、コンストラクタはオーバーロードも可能です。  
初期化のタイミングで、型に合わせた処理をさせたい場合は、オーバーロードしましょう。

#### コンストラクタを利用する例

コンストラクタに引数を付けた場合、以下のようなサンプルコードで動作を確認できます。

```java
public class Person {
    private String name;
    private int age;

    // 引数なしコンストラクタ
    public Person() {
        System.out.println("引数なしコンストラクタが呼ばれました");
        this.name = "unknown";
        this.age = 0;
    }

    // 引数ありコンストラクタ（名前のみ）
    public Person(String name) {
        System.out.println("引数ありコンストラクタ（名前のみ）が呼ばれました");
        this.name = name;
        this.age = 0;
    }

    // 引数ありコンストラクタ（名前と年齢）
    public Person(String name, int age) {
        System.out.println("引数ありコンストラクタ（名前と年齢）が呼ばれました");
        this.name = name;
        this.age = age;
    }

    // 名前を取得するメソッド
    public String getName() {
        return this.name;
    }

    // 年齢を取得するメソッド
    public int getAge() {
        return this.age;
    }

    // 名前と年齢を表示するメソッド
    public void displayInfo() {
        System.out.println("Name: " + this.name + ", Age: " + this.age);
    }

    public static void main(String[] args) {
        Person person1 = new Person();
        person1.displayInfo();
        
        Person person2 = new Person("Alice");
        person2.displayInfo();
        
        Person person3 = new Person("Bob", 30);
        person3.displayInfo();
    }
}
```

##### 上記コードの解説
このコードでは、`Person`クラスが定義されています。
`Person`クラスには、`name`（名前）と`age`（年齢）という2つのprivateなフィールドがあります。

コンストラクタは以下の3種類を用意しています。

1. 引数なしコンストラクタ：名前と年齢の初期値を設定します。
2. 引数ありコンストラクタ（名前のみ）：名前を設定し、年齢の初期値を設定します。
3. 引数ありコンストラクタ（名前と年齢）：名前と年齢を設定します。

その他に、`getName`と`getAge`メソッドは、それぞれ名前と年齢を取得するためのメソッドです。`displayInfo`メソッドは、名前と年齢を表示するためのメソッドです。

`main`メソッドでは、それぞれのコンストラクタを使って3つの`Person`オブジェクト（person1、person2、person3）を生成しています。  
それぞれのオブジェクトに対して`displayInfo`メソッドを呼び出すことで、名前と年齢が表示されます。

また、コンストラクタ内に設定されたメッセージ出力により、引数の有無で呼び出されているコンストラクタが異なることが分かります。

### コンストラクタ内で他のコンストラクタを呼べる`this()`

同一のクラス内でコンストラクタから他のコンストラクタを呼び出せます。
その場合、`this()`を使用します。

使い方としては以下の様なパターンが考えられます。

```java
public class MyClass {
    int field;

    public MyClass() {
        //引数が設定されなかった場合は初期値を設定するために引数付きのコンストラクタを呼び出す
        this(1);
    }
    public MyClass(int val) {
        this.field = val;
    }
}
```

上記例の他に、引数なしのコンストラクタにクラスの共通的な初期化処理を書き、引数ありのコンストラクタから`this()`で引数なしコンストラクタを呼び出すことで処理を共通化させることも可能です。


## コンストラクタにもアクセス制限を設けることができる

「引数無しのコンストラクタだけは外部からアクセスされたくない」と言う特殊な状況の場合は以下のようにすることもできます。

これで、外部からnew演算子でインスタンス化する際に引数なしでは呼び出せなくなります。

```java
public class MyClass {
    int field;

    private MyClass() {
        //外部からは呼び出せない
    }
    public MyClass(int val) {

    }
}
```

呼び出す側では、以下のように、引数なしの場合にコンパイルエラーが出るようになります。

```java
MyClass mc = new MyClass();    //コンパイルエラーとなる
MyClass mc = new MyClass( 1 ); //こっちはOK
```

### コンストラクタにアクセス制限を付ける場合の注意点

すべてのコンストラクタを`private`などにしてしまうと、そのクラスはインスタンス化出来なくなり、他のクラスから使うことができません。
どれか1つは`public`か`指定なし`にしておきましょう。


## まとめ
クラスのフィールドを初期化する処理などは、コンストラクタで書いておくと、利用者側はインスタンス化後に値を個別に指定する作業をすることなく使用できます。
これにより、初期化のための何らかの処理を利用者側にやらせることが少なくなり、結果として間違った利用方法でクラスを利用されることが少なくなります。

また、コンストラクタにアクセス制限を設ける場合は、使用して欲しい初期化処理をクラス利用者に伝えることができます。
適切なアクセス制限を設けることで、利用者が利用方法に迷いにくくなります。