---
title: 抽象クラスと抽象メソッド
---

## 抽象クラス(アブストラクトクラス)

### 抽象クラスとは

1. 親クラス（スーパークラス）としてのみ使用されることを想定しているクラスのこと。
2. 抽象クラスは、抽象メソッド（アブストラクトメソッド）を持つことができる。
    - 抽象メソッドの処理内容は、抽象クラス内で定義しません。
    - 抽象メソッドは、継承先である子クラス（サブクラス）にて必ずオーバーライドしなければいけません。

### どんなときに使うのか

継承を使うことを想定した設計の場合、以下のような場面があります。

1. 継承されることが前提の親クラスとしてクラスを書きたい
2. メソッドの処理内容は継承先の子クラスで処理内容が決定する
3. 子クラスで決定するメソッドの処理内容を親クラスで書きたくない

このとき、やってはいけない書き方として、以下のものがあります。

```java
public class SuperClass {
    public void overRidableMethod() {
        //何らかの処理

        //このメソッドは、オーバーライドしてもしなくても良いメソッド
    }

    //このメソッドは、オーバーライドして中身を書いて欲しいメソッドとする（これは絶対やっちゃダメ）
    public void mustOverRideMethod(int a) { /* 子クラスで実装してください */ }
}
```

これでは、`mustOverRideMethod`が子クラスでオーバーライドされるかどうかは子クラスの作成者次第となってしまいます。

継承の仕組みを活用してアップキャストによる型の管理がされる場合、このメソッドを用いて子クラスごとに処理を切り替えたく、この親クラスをオーバーライドした上で子クラスにて個別の処理を必ず書く必要があります。  
しかし、メソッドがオーバーライドされたかどうかは、テストするかレビューなどでチェックするしかなく、強制力がありません。

また、親クラスとして作成している`SuperClass`は、これ自体をインスタンス化して使用することはありません。

こういった場合に、抽象クラス（抽象メソッド）の仕組みを使えます。

### 抽象クラスの宣言

クラス宣言部に、**abstract修飾子** を付けます。


```java
public abstract class SuperClass {
    ...
}
```

こうすることで`SuperClass`は抽象クラスとして動作します。

制約として、`new SuperClass();`のようにSuperClass自体をインスタンス化することはできません。  
(`SuperClass`親とする子クラスとして、`SubClass`を定義している場合、`SuperClass s = new SubClass();`は可能です。)


### 抽象クラスを継承するには

通常のクラスを継承するのと同様に、子クラスの宣言部にて**extends**構文で継承できます。

### 抽象メソッドの宣言

メソッドの宣言部に、**abstract修飾子** を付け、`{}`ではなく、`;`でメソッド定義だけを1文とします。

```java
public abstract void mustOverRideMethod(int a);
```

### 抽象メソッドを持つ抽象クラスを継承した場合

上記の良くない例を、抽象クラス、抽象メソッドで書きなおしたものが以下のものになります。

```java
//抽象クラス
public abstract class SuperClass {
    public void overRidableMethod() {
        //何らかの処理

        //このメソッドは、オーバーライドしてもしなくても良いメソッド
    }

    //このメソッドは、オーバーライドして中身を書いて欲しいメソッドとする
    public abstract void mustOverRideMethod(int a);
}


//子クラス
public class SubClass extends SuperClass {

    //overRidableMethodはオーバーライドしてもしなくてもよい

    @Override
    public void mustOverRideMethod(int a) {

        //子クラスにて確定しているmustOverRideMethodの処理の中身を書く

    }
    //↑このメソッドを書かいてオーバーライドしないとエラーとなる。
}
```

### 抽象メソッドのメリット

1. 子クラスでオーバーライドしないとコンパイルエラーとなり、オーバーライドを強制することができる
2. 抽象クラスを継承した複数の子クラスにて、処理内容の違う抽象メソッドと同じ名前のメソッドが作られる形となり、アップキャストによる処理をより便利に書くことができる

たとえば、以下のコードを見てください。

```java
//抽象クラス
public abstract class SuperClass {
    public abstract void showMessage();
}
//子クラス1
public class SubClass1 extends SuperClass {
    @Override
    public void showMessage() {
        System.out.println("1");
    }
}
//子クラス2
public class SubClass2 extends SuperClass {
    @Override
    public void showMessage() {
        System.out.println("2");
    }
}
public class Sample {
    public static void main(String[] args) {
        SuperClass[] sa = {
            new SubClass1(),
            new SubClass2(),
        };

        for (int i = 0; i < sa.length; i++) {
            sa[i].showMessage();
        }
    }
}
```

`Sample`クラスを実行すると、以下の結果が得られます。

```bash
1
2
```

このように抽象クラスを親に持つ子クラスは、親クラスにアップキャスト（上記例では、どちらも`SuperClass`の配列に格納している）して同じメソッド名でメソッドを呼び出すことができます。
そのメソッドの処理内容は、それぞれの子クラスのメソッドの処理が行われます。

（※この仕組みを使うと、if文による条件分岐ではなく、子クラスの実体を何にするかによる条件分岐が可能になります。設計自体が複雑になるため、普通にif文で条件分岐させた方が分かりやすい場合もあるのでこれを前提とした設計は多用しないようにしましょう。）

### 抽象クラスのコンストラクタ

継承の解説の際にも説明しましたが、子クラスのコンストラクタは、暗黙的に親クラスの引数なしコンストラクタ`super()`が呼び出されます。
抽象クラスのコンストラクタも、`super()`によって呼び出されます。処理を何もしない場合はコンストラクタ自体を省略が可能なのは通常の継承を行うクラスでも一緒です。



## 抽象クラス抽象メソッドまとめ
+ 内容未確定のメソッドを持つクラスを定義できる
+ 直接インスタンス化はできない
    - `new`演算子を使うことはできないが、型として宣言することは可能
+ 子クラスごとに異なる機能を持つ同じメソッド名のメソッドを必ず持たせる事ができる
    - 「なにもしない」メソッドとは区別が必要です。
+ 抽象クラスを型とした変数を用意すればアップキャストにより子クラスを格納することができる
+ 引数として抽象クラスを型とすれば子クラスのインスタンスを渡す事ができる
    - どの子クラスが渡されたかを判断する演算子として、**instanceof演算子** があります。


## instanceof演算子

instanceof演算子は、そのオブジェクトが指定したクラスのインスタンスかどうかをbooleanで返す演算子です。

構文としては以下のようになります。

```java
if (変数名 instanceof クラス名) {
    //変数が指定したクラスのオブジェクトである場合
}
```

`抽象メソッドのメリット`で書いた抽象クラスと抽象メソッドはそのままでの使用例を以下に書きます。

```java
public class Sample {
    public static void main(String[] args) {
        SuperClass[] sa = {
            new SubClass1(),
            new SubClass2(),
        };

        for (int i = 0; i < sa.length; i++) {
            if (sa[i] instanceof SubClass1){
                System.out.print("これは子クラス1です。：");
            } else {
                System.out.print("これは子クラス1ではありません。：");
            }
            sa[i].showMessage();
        }
    }
}
```
として実行すると、以下の結果が得られます。

```bash
これは子クラス1です。：1
これは子クラス1ではありません。：2
```

どのクラスのインスタンスかを判断できる演算子ですので、抽象クラスに限らず、アップキャストを利用した仕組みを作成する場合に有効活用できるでしょう。
