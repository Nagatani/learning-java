---
title: インターフェイス
---

## インターフェイス(interface)とは

抽象クラスをさらに抽象化し「型」だけを定義するメカニズムのこと。

インターフェイスには、定数とメソッドの定義（抽象メソッド）を書きます。  
定義したインターフェイスを実装するクラスはインターフェイスの定義を忠実に守り処理を実装することを強制できます。

クラスに持たせるべきメソッドの定義を書く設計図となり、***インターフェイスを実装した各クラスは、インターフェイスへのアップキャストが可能***です。

### 「インターフェイスを作る」ということは「仕様」を決定すること

「インターフェイスを作る」ということは、それを実装するクラスに「〇〇というメソッドを持っており、実行すると✕✕という結果が返ります」という決め事を先に作ることに等しいです。
これは言ってみればプログラムソース上で決定される「仕様」となります。

「インターフェイスによって定義された型をクラスに持たせることができる」という考え方でもよいでしょう。

インターフェイスはオブジェクト指向による設計・プログラミングを行うにあたって、振る舞いの名前や、それに必要なデータ型、それによって得られる結果を決めておくことができる重要な機能と言えます。


## Javaのインターフェイス
### interface定義構文

インターフェイスを定義する場合には、通常のクラス宣言の`class`を`interface`として定義します。

構文としては以下のようになります。

```java
package パッケージ名;
アクセス修飾子 interface インターフェイス名 {

    定数フィールドの宣言

    抽象メソッドの宣言

}
```

## interface実装構文

クラスを「継承」する場合には、`extends`を使用しました。  
インターフェイスを「実装」する場合には、`implements`を使用します。


```java
package パッケージ名;
アクセス修飾子 class クラス名 implements インターフェイス名 {

    クラスのフィールド

    クラスのメソッド

    インターフェイスで作成した抽象メソッドのオーバーライド

}
```

インターフェイスで用意されたメソッドは、実装を行うクラスにてオーバーライドしないと、コンパイルエラーとなります。


また、インターフェイスは「継承」と異なり、複数のインターフェイスをクラスで「実装」することが可能です。  
以下の書き方のように、`implements`のあとに、インターフェイスを「,（カンマ）」で区切ることで複数のインターフェイスを実装できます。

```java
package パッケージ名;
アクセス修飾子 class クラス名 implements インターフェイス1名, インターフェイス2名, インターフェイス3名 {

    クラスのフィールド

    クラスのメソッド

    インターフェイス1で作成した抽象メソッドのオーバーライド

    インターフェイス2で作成した抽象メソッドのオーバーライド

    インターフェイス3で作成した抽象メソッドのオーバーライド
}
```

この場合、上記の「クラス名というクラス」は「インターフェイス1」としても振る舞い、「インターフェイス2」としても振る舞い、「インターフェイス3」としても振る舞うことができます。


## interfaceが持てるもの

Javaのインターフェイスは、以下のものが定義できます。

- 定数フィールド
    + 値が変化するフィールドは持てません。
    + interface内で、`int a = 1;`とすると、内部的には、`public final static int a = 1;`として処理されます。もちろん値の変更はできません。
- 抽象メソッド
    + interface内で`void method(int a);`とすると、内部的には、`public abstract void method(int a);`として定義されています。
- `default`修飾メソッド（この資料にて後ほど詳しく説明があります）
    + `default`修飾子というインターフェイス専用の修飾子をメソッド定義に使用すると、基本となる処理内容を書くことが可能です。
    + `default void method(int a) { メソッドの処理内容 }`とすると、子クラスではこのメソッドをオーバーライドしなくてもよくなり、オーバーライドしない場合はインターフェイスで定義したメソッドの処理内容が実行されます。
    + ただし、これにより多重継承が行えるようになってしまいます。インターフェイスを多重で実装する場合は、同名のメソッドが存在する場合は、必ず子クラスでオーバーライドしてください。
- `static`修飾メソッド
    + インスタンスを必要としない（インスタンス化しなくても使える）staticメソッドは実装可能です。
    + `static void method(int a) { メソッドの処理内容 }`とすると、暗黙的に`public static void method(int a) { メソッドの処理内容 }`として定義されます。
    + staticメソッドだけは`private`修飾子が使用でき、`private static`なメソッドはインターフェイス内の`default`や`static`のメソッドから呼び出せます。
    + staticなメソッドから、`default`メソッドを呼ぶことはできません。（通常のクラスにおけるstaticメソッドからインスタンスメソッドを呼べない制約と同じです。）

Javaのアップデートにより、インターフェイスにはいくつもの新機能が追加されており、`default`,`static`はその代表的なものです。

## interfaceはinterfaceを「継承」できる

```java
package パッケージ名;
アクセス修飾子 interface 子インターフェイス名 extends 親インターフェイス名 {

    定数フィールドの宣言

    メソッドの宣言

}
```

この場合、子インターフェイスは親インターフェイスのフィールド、抽象メソッドを継承しています。

## interfaceの特徴まとめ

- 抽象クラスと同様に、new演算子によるインスタンス化はできない
    + ただし、型として宣言することが可能で、そのインターフェイスを実装しているクラスのインスタンスが格納できる
- インターフェイスは定数と抽象メソッド、defaultメソッド（※後述）しか持てない
    + 定数の`public final static`修飾子や、抽象メソッドの`public abstract`は省略可能。
- クラスは複数のインターフェイスを実装できる
    + すべてのインターフェイスの抽象メソッドをオーバーライドする必要があります。
- インターフェイスはインターフェイスを「継承」できる
    + インターフェイスの抽象化を実現できるが、安易に使うと複雑化してしまうためオススメはしません。


----


## インターフェイスを用いた多重継承

### defalt修飾子を用いた処理の実装

`default`修飾子と呼ばれるインターフェイスのみで使用できるメソッド定義があります。
このメソッドはインターフェイスなのに処理内容を書けます。
`default`メソッドはインターフェイスを実装したクラスでオーバーライドしなくてもよく、オーバーライドがされなければインターフェイスで書かれているメソッドの処理内容が実行されます。

`default`メソッドは、下記のように定義でき、`default`メソッドから`default`メソッドを呼ぶことも可能です。

```java
void methodA();
default void methodBtoA() {
    methodA();
}
default int methodHoge() {
    return 42;
}
```

これにより、インターフェイスを複数実装する場合でも処理を継承できます。  

### 多重継承で同じメソッドが複数のインターフェイスで定義されている場合はどうなるか

同じメソッド（メソッド名、引数が同じ）場合、継承を行うと、どっちのメソッドを呼べば良いのか判断がつかなくなります。  
（これが設計上の問題として存在するので、Javaではextendsを用いた多重継承ができない設計となっていたのです……。）

しかし、インターフェイスでのメソッド定義は、抽象メソッドが基本となります。  
インターフェイスにて抽象メソッドのみ定義されている場合は、「実装を行ったクラスにてそのメソッドがオーバーライドされていれ」ば問題ありません。

同じ名前、引数のデフォルトメソッドが複数定義されている場合、クラスにて必ずオーバーライドする必要があります。  
デフォルトメソッドの中に書かれた処理は多重継承にてバッティングした場合に使えなくなりますのでご注意ください。（オーバーライドしないとコンパイルエラーとなります）

余談:  
C++などの一部の言語では、クラスを複数extendsできるものもあります。  
Javaはそれを許容しませんでした。そのかわりに、インターフェイスの概念を導入することとなっていたはず……なのですが、Java 8以降ではそこが見直され右倣えしたこととなります。  
多重継承した場合にちゃんとコンパイルエラーを出せれば良いという状況になってくれたのは良いことなのかそれとも、そもそも複数extendsできても良いのでは？と思うこともあります。

## インターフェイスを扱う場合に注意しておいて欲しいこと

- インターフェイスは設計段階で用意すること
- インターフェイスの仕様変更は影響範囲がかなり大きいので、後からメソッドの追加や変更は慎重に行うこと
- 定数だけ持つインターフェイスは作らない
    + 定数だけを持つインターフェイスも作れます。しかし、それはインターフェイスでなくても良いはずです。
    + 定数だけを持つクラスを作りたい場合は、インターフェイスでもクラスでもなく、列挙型の`enum`があるためこちらを使うと良いです。
